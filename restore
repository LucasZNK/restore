#!/bin/bash

# Claude Interactive Git Restore Tool
# Author: Claude Assistant  
# Description: Interactive arrow-navigable git commit browser and restore tool

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Emojis and symbols
ARROW="‚Üí"
CURRENT_MARK="üî•"
FRESH_MARK="‚ú®"
COMMIT_MARK="üìù"
BRANCH_MARK="üåø"
TIME_MARK="‚è∞"

# Terminal control
clear_screen() {
    printf '\033[2J\033[H'
}

hide_cursor() {
    printf '\033[?25l'
}

show_cursor() {
    printf '\033[?25h'
}

move_cursor() {
    printf '\033[%d;%dH' "$1" "$2"
}

# Cleanup function
cleanup() {
    show_cursor
    stty echo
    exit 0
}

trap cleanup EXIT INT TERM

# Function to check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi
}

# Function to get commit data
get_commits() {
    git log --oneline --format="%H|%h|%s|%ad|%an" --date=format:"%Y-%m-%d %H:%M" -15 2>/dev/null
}

# Function to get relative time
get_relative_time() {
    local commit_hash=$1
    git log -1 --format="%ar" "$commit_hash" 2>/dev/null
}

# Function to get current branch and commit info
get_current_info() {
    local current_branch=$(git branch --show-current 2>/dev/null)
    local current_commit=$(git rev-parse HEAD 2>/dev/null)
    echo "$current_branch|$current_commit"
}

# Function to truncate text
truncate_text() {
    local text="$1"
    local max_length="$2"
    if [ ${#text} -gt $max_length ]; then
        echo "${text:0:$((max_length-3))}..."
    else
        echo "$text"
    fi
}

# Function to draw header
draw_header() {
    local current_info=$1
    IFS='|' read -r current_branch current_commit <<< "$current_info"
    
    clear_screen
    
    echo -e "${BOLD}${MAGENTA}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}"
    echo -e "${BOLD}${MAGENTA}‚îÇ${NC}  ${BOLD}${CYAN}üîÑ Interactive Git Restore Tool${NC}                                      ${BOLD}${MAGENTA}‚îÇ${NC}"
    echo -e "${BOLD}${MAGENTA}‚îÇ${NC}  ${DIM}Navigate with ‚Üë‚Üì arrows, Enter to select, q to quit${NC}                  ${BOLD}${MAGENTA}‚îÇ${NC}"
    echo -e "${BOLD}${MAGENTA}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}"
    echo ""
    
    echo -e "  ${BRANCH_MARK} ${BOLD}Branch:${NC} ${CYAN}${current_branch:-'(detached HEAD)'}${NC}"
    echo -e "  ${COMMIT_MARK} ${BOLD}Current:${NC} ${GRAY}${current_commit:0:7}${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}Recent Commits:${NC}"
    echo ""
}

# Function to draw commit list
draw_commits() {
    local commits="$1"
    local selected="$2"
    local current_commit="$3"
    local line_num=9
    
    local i=0
    while IFS='|' read -r full_hash short_hash message date author; do
        local relative_time=$(get_relative_time "$full_hash")
        local truncated_msg=$(truncate_text "$message" 50)
        local truncated_author=$(truncate_text "$author" 15)
        
        move_cursor $line_num 1
        
        # Determine styling
        local prefix="  "
        local commit_style=""
        local message_style=""
        local is_current=false
        local is_fresh=false
        
        # Check if this is the current commit
        if [ "$full_hash" = "$current_commit" ]; then
            is_current=true
        fi
        
        # Check if this is the most recent (fresh) commit
        if [ $i -eq 0 ]; then
            is_fresh=true
        fi
        
        # Set selection styling
        if [ $i -eq $selected ]; then
            prefix="${BOLD}${CYAN}${ARROW}${NC} "
            commit_style="${BOLD}${WHITE}"
            message_style="${BOLD}${YELLOW}"
        else
            prefix="  "
            commit_style="${GRAY}"
            message_style="${NC}"
        fi
        
        # Build the line
        local line=""
        
        # Add markers
        if $is_current && $is_fresh; then
            line="${prefix}${CURRENT_MARK}${FRESH_MARK}"
        elif $is_current; then
            line="${prefix}${CURRENT_MARK} "
        elif $is_fresh; then
            line="${prefix}${FRESH_MARK} "
        else
            line="${prefix}  "
        fi
        
        # Add commit info
        line="${line} ${commit_style}${short_hash}${NC}"
        line="${line} ${message_style}${truncated_msg}${NC}"
        
        # Add metadata
        line="${line} ${DIM}${TIME_MARK}${relative_time} by ${truncated_author}${NC}"
        
        # Clear line and print
        printf '\033[K'
        echo -e "$line"
        
        ((i++))
        ((line_num++))
    done <<< "$commits"
    
    # Clear remaining lines
    for ((j=line_num; j<=25; j++)); do
        move_cursor $j 1
        printf '\033[K'
    done
}

# Function to show commit details
show_commit_details() {
    local commit_hash=$1
    local short_hash=$2
    local message=$3
    local date=$4
    local author=$5
    
    clear_screen
    
    echo -e "${BOLD}${CYAN}‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ${NC}"
    echo -e "${BOLD}${CYAN}‚îÇ${NC}  ${BOLD}${WHITE}üìã Commit Details${NC}                                                    ${BOLD}${CYAN}‚îÇ${NC}"
    echo -e "${BOLD}${CYAN}‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ${NC}"
    echo ""
    
    echo -e "  ${BOLD}Hash:${NC}    ${YELLOW}${short_hash}${NC} (${GRAY}${commit_hash}${NC})"
    echo -e "  ${BOLD}Message:${NC} ${WHITE}${message}${NC}"
    echo -e "  ${BOLD}Date:${NC}    ${CYAN}${date}${NC}"
    echo -e "  ${BOLD}Author:${NC}  ${GREEN}${author}${NC}"
    echo ""
    
    # Show commit body if exists
    local body=$(git log -1 --format="%b" "$commit_hash" 2>/dev/null | sed '/^$/d')
    if [ -n "$body" ]; then
        echo -e "${BOLD}Extended message:${NC}"
        echo "$body" | sed 's/^/  /'
        echo ""
    fi
    
    # Show file changes
    echo -e "${BOLD}Files changed:${NC}"
    git show --stat --format="" "$commit_hash" 2>/dev/null | head -n -1 | sed 's/^/  /'
    echo ""
    
    # Show summary
    local summary=$(git show --stat --format="" "$commit_hash" 2>/dev/null | tail -1)
    echo -e "${BOLD}Summary:${NC} $summary"
    echo ""
    
    echo -e "${BOLD}${YELLOW}Do you want to restore to this commit? [y/N]${NC}"
    read -p "$(echo -e ${CYAN}Choice: ${NC})" choice
    
    if [[ $choice =~ ^[Yy]$ ]]; then
        perform_restore "$commit_hash" "$short_hash" "$message"
    fi
}

# Function to handle uncommitted changes
handle_uncommitted_changes() {
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "\n${YELLOW}‚ö†Ô∏è  Warning: You have uncommitted changes${NC}"
        echo -e "\nWhat would you like to do?"
        echo -e "${BOLD}1)${NC} Stash changes and continue"
        echo -e "${BOLD}2)${NC} Discard changes and continue"
        echo -e "${BOLD}3)${NC} Cancel restore"
        
        while true; do
            read -p "$(echo -e ${CYAN}Choice [1-3]: ${NC})" choice
            
            case $choice in
                1)
                    echo -e "\n${BLUE}Stashing changes...${NC}"
                    git stash push -m "Auto-stash before restore at $(date)"
                    echo -e "${GREEN}‚úì Changes stashed${NC}"
                    return 0
                    ;;
                2)
                    echo -e "\n${YELLOW}Are you sure you want to discard all changes? [y/N]${NC}"
                    read -p "" confirm
                    if [[ $confirm =~ ^[Yy]$ ]]; then
                        echo -e "${BLUE}Discarding changes...${NC}"
                        git reset --hard HEAD
                        git clean -fd
                        echo -e "${GREEN}‚úì Changes discarded${NC}"
                        return 0
                    fi
                    ;;
                3)
                    echo -e "${YELLOW}Restore cancelled${NC}"
                    return 1
                    ;;
                *)
                    echo -e "${RED}Invalid choice. Please select 1-3${NC}"
                    ;;
            esac
        done
    fi
    return 0
}

# Function to perform restore
perform_restore() {
    local commit_hash=$1
    local short_hash=$2
    local message=$3
    
    echo -e "\n${BLUE}Restoring to commit ${short_hash}...${NC}"
    
    # Handle uncommitted changes
    if ! handle_uncommitted_changes; then
        return 1
    fi
    
    if git checkout "$commit_hash" 2>/dev/null; then
        echo -e "\n${GREEN}‚úÖ Successfully restored to commit ${short_hash}${NC}"
        echo -e "${GREEN}üìù ${message}${NC}"
        echo -e "\n${YELLOW}Note:${NC} You are now in 'detached HEAD' state."
        echo -e "To create a new branch: ${CYAN}git checkout -b <branch-name>${NC}"
        echo -e "To return to your branch: ${CYAN}git checkout <branch-name>${NC}"
    else
        echo -e "${RED}Error: Failed to restore${NC}"
        return 1
    fi
}

# Main interactive function
main() {
    check_git_repo
    
    # Get commit data
    local commits=$(get_commits)
    local current_info=$(get_current_info)
    IFS='|' read -r current_branch current_commit <<< "$current_info"
    
    if [ -z "$commits" ]; then
        echo -e "${YELLOW}No commits found.${NC}"
        exit 0
    fi
    
    # Convert commits to array
    local commit_array=()
    while IFS='|' read -r line; do
        commit_array+=("$line")
    done <<< "$commits"
    
    local selected=0
    local total=${#commit_array[@]}
    
    # Hide cursor and disable echo
    hide_cursor
    stty -echo
    
    # Initial draw
    draw_header "$current_info"
    draw_commits "$commits" "$selected" "$current_commit"
    
    # Main loop
    while true; do
        # Read single character
        read -rsn1 key
        
        case $key in
            $'\x1b')  # ESC sequence
                read -rsn2 -t 1 rest
                case $rest in
                    '[A')  # Up arrow
                        if [ $selected -gt 0 ]; then
                            ((selected--))
                            draw_commits "$commits" "$selected" "$current_commit"
                        fi
                        ;;
                    '[B')  # Down arrow
                        if [ $selected -lt $((total-1)) ]; then
                            ((selected++))
                            draw_commits "$commits" "$selected" "$current_commit"
                        fi
                        ;;
                esac
                ;;
            '')  # Enter key
                # Get selected commit data
                local selected_commit="${commit_array[$selected]}"
                IFS='|' read -r full_hash short_hash message date author <<< "$selected_commit"
                
                show_cursor
                stty echo
                show_commit_details "$full_hash" "$short_hash" "$message" "$date" "$author"
                exit 0
                ;;
            'q'|'Q')  # Quit
                break
                ;;
        esac
    done
    
    # Cleanup
    show_cursor
    stty echo
    echo -e "\n${YELLOW}Exiting...${NC}"
}

# Run main function
main